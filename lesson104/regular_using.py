#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Time    : 2020/2/20 16:09
# @Author  : tanxw
# @Desc    : 正则表达式使用

# . 匹配除换行符(\n)之外的任意 单个字符 字符串 123\n456，匹配  123：1.3
# ^ 匹配字符串开头abc\nxyz，匹配以abc开头的行：^abc
# $ 匹配字符串结尾abc\nxyz，匹配以 xyz 结束的行：xyz$
# * 匹配0个或多个hello\nword，匹配以  w 开头d结尾的单词：w*d
# + 匹配1个或多个abc\nabcc\nadf，匹配abc和abcc：ab+
# ？匹配0个或1个abc\nac\nadd，非贪婪方式，匹配abc或ac：a?c
# [.] 匹配中括号之中的任意一个字符abcd\nadd\nbbb，匹配abcd和add：[abc]
# [ .-.] 匹配中括号中范围内的任意一个字符abcd\nadd\nbbb，匹配abcd和add：[a-c]
# [^]  匹配[^字符]之外的任意一个字符abc\n\abb\nddd，不匹配abc和abb：[^a-c]
# {n}或 {n,}  匹配花括号前面字符至少n个字符1\n\12\n123\n1234，匹配123和1234：[0-9]{3}
# {n,m}   匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式 1\n\12\n123\n1234\n12345，匹配123和1234：[0-9]{3,4}
# |  匹配竖杠两边的 任意一个  abc\nabd\abe，匹配  abc 和  abd：ab（c|d）
# \  转义符，将特殊 符号转成原有意义 1.2，匹配1.2：1\.2，否则112也会匹配到

# 未予归类的用法，re 代表字符
# (?imx)	正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。
# (?-imx)	正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。
# (?: re)	类似 (...), 但是不表示一个组
# (?imx: re) 在括号中使用i, m, 或 x 可选标志
# (?-imx: re)	在括号中不使用i, m, 或 x 可选标志
# (?#...)	注释.
# (?= re)	前向肯定界定符。如果所含正则表达式，以 ... 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。
# (?! re)	前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功
# (?> re)	匹配的独立模式，省去回溯。


# \A 匹配字符串开始  与^区别是：当使用修饰符  re.M 匹配多行时，\A 将 所有字符串作为一整行处理。abc123\nabc456，匹配  abc123：\Aabc，^则都会匹 配到
# \Z 匹配字符串结束  与\A 同理
# \b 匹配字符串开始或结束（边界符）  abc\nabcd，匹配  a 开头并且  c 结尾字符串：\babc\b
# \B 与\b 相反


# 特殊字符类
# \d 匹配任意十进制 数，等效[0-9]  1\n123\nabc，匹配  1 和  123：[0-9]，包含单个数字 的都会匹配到，如果只想匹配  1：\b[0-9]\b
# \D 匹配任意非数字字 符，等效[^0-9] 1\n12\nabc，匹配  abc：[^0-9]
# \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]  如 1\n a，注意  a 前面有个空格，匹配  a：\s。。
# \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
# \w 匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。
# \W 匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。
# () 对正则表达式分组并记住匹配的文本，常用作于对正则表达式进行分组；匹配子组

# 字符类实例
# [Pp]ython	匹配 "Python" 或 "python"
# rub[ye]	匹配 "ruby" 或 "rube"
# [aeiou]	匹配中括号内的任意一个字母
# [0-9]	匹配任何数字。类似于 [0123456789]
# [a-z]	匹配任何小写字母
# [A-Z]	匹配任何大写字母
# [a-zA-Z0-9]	匹配任何字母及数字
# [^aeiou]	除了aeiou字母以外的所有字符
# [^0-9]	匹配除了数字外的字符
#######################################################################################################################
# re.compile()
# 把正则表达式编译成一个对象，方便再次调用：
import re
# prog = re.compile(pattern)
# result = prog.match(string)
# 等效于
# result = re.match(pattern, string)

def displaymatch(match):
    if match is None:
        return None
    return '<Match: %r, group=%r>' % (match.group(), match.groups())

valid = re.compile(r"^[a-c1-3]{3}$")
print(displaymatch(valid.match("a1b")))
print(displaymatch(valid.match("a1b2")))
print(displaymatch(valid.match("bbb")))


#######################################################################################################################


# re.match()
# 判断字符串开头是否匹配字符
m = re.match(r'hello', 'hello world')
print(m)

m12 = re.match(r'(\w+) (\w+)', 'hello world')
print(m12.group(0))
print(m12.group(1))
print(m12.group(2))
print(m12.group(1,2))



#######################################################################################################################
# 通过分子重命名的名字来引用分组结果：
m = re.match(r'(?P<first_name>\w+) (?P<last_name>\w+)', 'hello world')
print(m.group('first_name'))
print(m.group('last_name'))
# 命名组也可以引用他们的索引
print(m.group(1))
print(m.group(2))

#######################################################################################################################
# 如果一组匹配多次，只有最后一个匹配：
m = re.match(r"(..)+", "a1b2c3")
print(m.group(1))

#######################################################################################################################
# groups([default])
# 返回一个元组包含所有子组的匹配。
m = re.match(r"(\d+)\.(\d+)", "24.1632")
print(m.groups())

#######################################################################################################################
# groupdict([default])
# 返回子组名字作为键，匹配结果作为值的字典。
m = re.match(r"(?P<first_name>\w+) (?P<last_name>\w+)", "hello world")
print(m.groupdict())

#######################################################################################################################
# 4）start()和 end()
# 例如：去掉邮件地址的某字符

email = "tony@163_126.com"
m = re.search(r"_126", email)
print(email[:m.start()] + email[m.end():])

#######################################################################################################################
# 5）span()
# 以列表形式返回匹配索引开始和结束值：
email = "tony@163_126.com"
m = re.search(r"_126", email)
print(m.span())

#######################################################################################################################
# 6）pos 和  endpos
# 返回字符串开始和结束索引值：
email = "tony@163_126.com"
m = re.search(r"_126", email)
print(m.pos)
print(m.endpos)

#######################################################################################################################
# search()
m = re.search(r"c", "abcdefc")
print(m.group())
print(m.span())

#######################################################################################################################
# split()
# 例如：以数字作为分隔符拆分字符串
m = re.split(r"\d+", "a1b2c3")
print(m)

#######################################################################################################################
# sub()
# 例如：替换  2016
m = re.sub(r"\d+", "2017", "the year 2016")
print(m)


#######################################################################################################################
# 例如：repl 作为一个函数
def repl(m):
    return str(int(m.group('v')) * 2)

m = re.sub(r'(?P<v>\d+)', repl, "123abc")
print(m)

#######################################################################################################################
# 例如：得到所有匹配的数字
text = "a1b2c3"
re.findall(r'\d+', text)
for m in re.finditer(r'\d+', text):
    print(m.group())

#######################################################################################################################
# 贪婪模式：尽可能最多匹配
# 非贪婪模式，尽可能最少匹配，一般在量词（*、+）后面加个问号就是非贪婪模式。
aaa = re.findall(r"<div>.*</div>", "<div>a</div><div>b</div><div>c</div>")
print(aaa)
aaa = re.findall(r"<div>.*?</div>", "<div>a</div><div>b</div><div>c</div>")
print(aaa)
bbb = re.findall(r"a(\d+)", "a123b")
print(bbb)
bbb = re.findall(r"a(\d+?)", "a123b")
print(bbb)
# 右边有限定，贪婪模式失效
bbb = re.findall(r"a(\d+)b", "a123b")
print(bbb)


